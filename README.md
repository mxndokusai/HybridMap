# HybridMap

A hash map implementation inspired by Optiver's internal design, as presented by [Carl Cook at CppCon 2017](https://youtu.be/NH1Tta7purM?si=5HT1RNdeYAKkx6d6&t=1532). Please do not use this in production.

## TLDR

Hash maps theoretically use either chaining or open addressing, each with their own tradeoffs. Here, we try implementing a hybrid-approach hash map.

We maintain two core data structures, `Slot` and `Entry`:

```cpp
struct Slot {
  size_t hash;  // Precomputed hash value (8 bytes).
  Entry* entry; // Pointer to key-value pair (8 bytes).
  Slot() : hash(0), entry(nullptr) {}
};              // Total: 16 bytes per slot (cache-aligned).
struct Entry {
  std::pair<const Key, Value> data;
  template <typename K, typename V>
  Entry(K &&k, V &&v) : data(std::forward<K>(k), std::forward<V>(v)) {}
};
```

- Main table contains only (hash, pointer) pairs.
- Actual key-value pairs stored separately in contiguous memory.
- Slot size: exactly 16 bytes for  cache alignment.
- 64-byte cache line accommodates exactly 4 slots. Other sizes defined by `std::hardware_destructive_interference_size` would likely still be a multiple of 16.
- Linear probing with power-of-2 table sizes and fast modulo via bitmasking.
- Tombstone based deletion via sentinel pointer tombstones using `reinterpret_cast<Entry*>(1)`.

Refer to the `tests/` or `benches/` directories for usage examples.

## Benchmarks

`benches1.cpp` were generated by Claude, while `benches2.cpp` were generated referencing [Martin Leitner-Ankerl's blogpost](https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/).
View a sample of benchmark outputs in `log.txt`. Note that some of the benchmark tests were not run as they crashed their environments, especially my Ubuntu server on Linode :(.
