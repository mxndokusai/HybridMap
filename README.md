# HybridMap

A hybrid hash map implementation taking inspiration from [Carl Cook @ CppCon 2017](https://youtu.be/NH1Tta7purM?si=5HT1RNdeYAKkx6d6&t=1532), with some exploratory optimisations. Please do not use this in production.

Hash maps theoretically use either chaining or open addressing, each with their own tradeoffs. Here, we try implementing a hybrid-approach hash map with two complementary strategies and automatically select between them at compile-time based on type characteristics.

### `NodeHashMap`

```cpp
struct Slot {
  size_t hash;  // Precomputed hash value (8 bytes).
  Entry* entry; // Pointer to key-value pair (8 bytes).
  Slot() : hash(0), entry(nullptr) {}
};              // Total: 16 bytes per slot (cache-aligned).

struct Entry {
  std::pair<const Key, Value> data;
  template <typename K, typename V>
  Entry(K &&k, V &&v) 
    : data(std::piecewise_construct,
           std::forward_as_tuple(std::forward<K>(k)),
           std::forward_as_tuple(std::forward<V>(v))) {}
};
```

- Main table contains only (hash, pointer) pairs.
- Actual key-value pairs stored separately on heap.
- Slot size: exactly 16 bytes for cache alignment.
- 64-byte cache line accommodates exactly 4 slots.
- Best for: large values, expensive moves, stable pointers.

### `FlatHashMap`

```cpp
struct alignas(64) Slot {
  size_t hash;
  alignas(alignof(Key)) std::byte key_storage[sizeof(Key)];
  alignas(alignof(Value)) std::byte value_storage[sizeof(Value)];
};
```

- Key-value pairs stored inline with hash.
- One cache line per slot for maximum locality.
- Uses placement new (`std::construct_at`) and `std::launder`.
- Best for: small types (<=56 bytes combined), cheap moves.

### `HashMap`

```cpp
template <typename Key, typename Value, typename Hash = std::hash<Key>>
using HashMap = std::conditional_t
    (sizeof(Key) + sizeof(Value) <= 56) &&
    std::is_nothrow_move_constructible_v<Key> &&
    std::is_nothrow_move_constructible_v<Value>,
    FlatHashMap<Key, Value, Hash>,
    NodeHashMap<Key, Value, Hash>>;
```

Compile-time selection based on:

- Size constraint (must fit in 56 bytes with hash).
- Move semantics (must be nothrow movable).
- Zero runtime overhead.

Shared optimisations:

- Linear probing for cache-friendly access patterns.
- Power of 2 table sizes enable fast modulo via bitmasking.
- Tombstone deletion via sentinel values.
- Auto rehashing based on load factor (0.75) or tombstone ratio (0.25).

### Benches

Refer to the `tests/` or `benches/` directories for usage examples.

`benches1.cpp` was generated by Claude, while `benches2.cpp` was generated referencing [Martin Leitner-Ankerl's blogpost](https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-01-overview/).
View a sample of benchmark outputs from `benches1` in `log.txt`. Note that there is not log for `benches2` as it crashed both my Mac and Ubuntu environments :(.
